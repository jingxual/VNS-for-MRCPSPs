"""Modified makespan: calculate new finish time"""
def modified_makespan(feas, d_im,P_prec,r,R_r,U_imr,nr=None,R_nr=None,U_imnr=None):
    """
    Calculate new finish time of new-generated precedence feasible schedules
    args:
        feas (list): schedules order generated by swapping/moving
    return:
        s (ndarray) 
        f (ndarray)
        modified_f (scalar): modified makespan
    """

    g, t = 0,0
    NS_g = 0
    C_g = []   # already scheduled and completed
    # E_g = []   # predecessors Predj have been completed 
    A_g = [1]  # active 
    SE_g = [1] # a subset of E_g, will start at time t_g
    
    s = np.zeros((len(num_r),len(A)))
    f = np.zeros((len(num_r),len(A)))

    D_i, U_i, U_im = data_process(A,d_im,U_imr)
    Prec_i = get_pred(P_prec)
        
    while len(uni(C_g, A_g)) <= len(A)-2:
    # while len(C_g) <= len(A):

        g += 1
        t += 1

        t_g = tMax
        for i in A_g:
            r_id,_ = typeR(U_im[i])
            t_g = min(t_g, f[r_id][i-1])

        t_g_i = []
        A_g_new = []
        for i in A_g:
            r_id,_ = typeR(U_im[i])
            if f[r_id,i-1]<=t_g:
                t_g_i.append(i)
            else: A_g_new.append(i)
        
        C_g = uni(C_g, t_g_i)
        A_g = A_g_new

        SE_g = []

        Rr_g = []
        for i in A_g:
            u_i = U_im[i]
            Rr_g.append(u_i)
        Rr_g = R_r - np.sum(Rr_g,axis=0)
        # Rnr_g = 

        # print("iter: ",g)
        # print("Complete: ",C_g)
        # print("Activate: ",A_g)
        # # print("Eligible: ",E_g)
        # print("SubE: ",SE_g)
        # print("\n")

        if len(C_g) == len(A)-1:
            print("end: ",C_g)
            break

        for k in range(NS_g,len(feas)):
            i_next = feas[k]
            u_i_next = U_im[i_next]

            # print("k: ", k)
            # print("i = ", i_next)
            # print("Rr_g: \n", Rr_g)
            
            out = False
            if i_next != 1:
                i_prec = Prec_i[i_next]
                for ip in i_prec:
                    if ip not in C_g:
                        # print("ip: ",ip)
                        NS_g = k
                        out = True
                        break
                    else: continue
            if out: break
            else:    
                if ((Rr_g-u_i_next)>=0).all():
                    # if ((Rnr_g-u_i_next)>=0).all(): 

                    r_id,r = typeR(u_i_next)

                    SE_g = uni(SE_g, [i_next])
                    A_g = uni(A_g, [i_next])
                    Rr_g -= u_i_next
                    # print("i: ",i_next, t_g)
                    s[r_id][i_next-1] = t_g
                else:
                    # print("false: ", i_next)
                    SE_g = SE_g
                    A_g = A_g
                    NS_g = k
                    break

        for i in SE_g:
            r_id,_ = typeR(U_im[i])
            f[r_id][i-1] = s[r_id][i-1] + D_i[i]

    modified_f = max(f.flatten())
    return s,f,modified_f
