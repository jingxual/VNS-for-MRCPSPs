"""Shaking phase: swap/move"""
run = 1000

def generate_init(runs):
    orders = []
    ord_dic = {}
    for k in range(runs):
        sk,fk,ok = initial_schedule2(d_im,P_prec,num_r,R_r,U_imr)
        f = max(fk.flatten())
        ord = [o[0] for o in list(ok.values())]
        if ord not in orders:
            orders.append(ord)
            if f not in ord_dic:
                ord_dic[f] = [ord]
            else: ord_dic[f].append(ord)
    return orders,ord_dic


def ifswap(id,i,cs):
    """
    Apply precedence and resource constraints
    args:
        id: current activity 
        i:  swap activity
        cs: current schedules
    return:
        ifswap (bool): if id and i can swap
    """
    i_pred = get_pred(P_prec)

    isvalid = False
    if i not in P_prec[id]:
        if set(i_pred[i]) <= set(cs[:id]):  # < if a include b; <= if b is subset of a
            isvalid = True
      
    return isvalid


def check_unique(feas_uni):
    """
    args:
        feas_uni (list): all feasible unique schedules after swapping
    return:
        isunique (bool) 
    """
    isunique = True
    for i,f in enumerate(feas_uni):
        ff = feas_uni[:i]+feas_uni[i+1:]
        if f in ff:
            ii = ff.index(f)
            print(i, ":", f, "same", ii)
            isunique = False
    return isunique


def swap(BS_uni):
    """
    Enhanced activity swapping strategy
    args:
        BS_uni (2d-list): a set of unique feasible schedules with best makespan generated by algorithm (a)
    """
    AS = []
    cnt = 0
    for p in range(len(BS_uni)):       # p: num of unique best schedules
        CS = BS_uni[p]
        for k in range(1,len(A)-1):    # k: activities available in project, excluding dummy end nodes, start from activity 1
            activity = CS[k]
            print("\n", k,":", activity, BS_uni[p])

            # forward swap
            CS_copy_f = copy.deepcopy(CS)
            for i in range(len(A)-1-k):
                id1 = CS_copy_f.index(activity)
                if ifswap(CS_copy_f[id1],CS_copy_f[k+i],CS_copy_f):   # apply constraints
                    CS_copy_f[id1],CS_copy_f[k+i] = CS_copy_f[k+i],CS_copy_f[id1]
                    print(p,k,i,CS_copy_f)
                    if CS_copy_f not in AS:   # if unique
                        cnt += 1
                        print(cnt, "Forward PICK: ", CS_copy_f)
                        find = copy.deepcopy(CS_copy_f)
                        AS.append(find)

            # backward swap
            CS_copy_b = copy.deepcopy(CS)
            for j in range(k-1):
                id2 = CS_copy_b.index(activity)
                if ifswap(CS_copy_b[k-j-1],CS_copy_b[id2],CS_copy_b):  # apply constraints
                    CS_copy_b[id2],CS_copy_b[k-j-1] = CS_copy_b[k-j-1],CS_copy_b[id2]
                    print(p,k,j,CS_copy_b)
                    if CS_copy_b not in AS:   # if unique
                        cnt += 1
                        print(cnt, "Backward PICK: ", CS_copy_b)
                        find = copy.deepcopy(CS_copy_b)
                        AS.append(find)
    
    if check_unique(AS):
        print("All feasible schedules are uniqe. GOOD LUCK.")
        return AS
    else:
        print("Please double check SWAP algorithm !!! ")
